\documentclass[12pt]{article}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{color}
\usepackage[frenchb]{babel}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{hyperref}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\begin{document}
\selectlanguage{frenchb} 
\title{NLP \\ Travail pratique 2 \\ Date de remise : 13 novembre 2015, 23h55.}
\author{Jonathan Gingras}

\maketitle

\begin{center}
\textbf{Nom:} Jonathan Gingras
\textbf{\\Matricule:} 111 004 940
\textbf{\\Numéro du cours:} IFT-7022
\end{center}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{a\&b) Préalales (installations et fichiers nécéssaires)}
Premièrement le choix de l'engin de recherche est \textit{ElasticSearch}. Il est donc nécéssaire, avant de rouler le projet, de démarrer une instance de \textit{ElasticSearch} roulant sur le port 9200 (le port par défaut). La version utilisée est 2.0.0. Il est possible qu'une autre version fonctionne, toutefois aucune autre n'a été testée.\\

Également, le projet est implémenté en Ruby (version 2.2.3 de l'interpréteur sous ma machine). Certaines dépendances sont nécéssaires pour rouler le projet. Voici la procédure pour les installer:\\

\begin{itemize}
\item Avoir \verb;bundler; :\\ \verb;$ gem install bundler;
\item \verb;cd; vers la racine du projet
\item \verb;$ bundle install --path vendor/bundle;\\
\end{itemize}

Les fichiers fournis pour le travail se trouvent dans les fichiers \verb;corpus.txt;, \verb;requests.txt; et \verb;pertinence.txt;. Ils proviennent directement du site du cours. 

\section{c) Indexation}
Avant de commencer, il est primordiale qu'une instance de \textit{ElasticSearch} roule sur le port 9200. L'indexation est faite en utilisant \verb;index.rb;. Il ne s'agit que de rouler:

\begin{verbatim}
$ ruby index.rb
\end{verbatim}

Il est toutefois assez long d'indexer les fichiers, il faut prévoir au moins 10 minutes pour les 4 configurations (chaque index différent correspondant à chaque configuration de la prochaine question).

Les détails quant à l'implémentation des appels \verb;REST; vers \verb;ElasticSearch; se retrouvent dans \verb;elastic_search.rb;.

\section{d) Expérimentation sur l'évaluation des différents facteurs}
Premièrement, pour tester les points demandés, le corpus fourni a été indexé avec plusieurs configurations différentes. Pour configurer les indexes utilisés pour les configurations demandées, les configurations des indexes \verb;ElasticSearch; se retrouvent dans le répertoire \verb;index_settings;.\\

Une première configuration est d'abord utilisée : \verb;normal;. Cette dernière correspond à la configuration standard pour la langue anglaise selon \textit{ElasticSearch}, tel que mentionné à \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html}. Cette configuration est utilisée pours buts de comparaison, pour évaluer l'influence seule des autres facteurs proposés.\\

Les autres configurations sont décrites dans les sous-sections suivantes pour répondre aux questions.

\subsection{La normalisation de mots par stemming}
Pour le \textit{stemming}, trois configurations sont testées: \verb;kstem;, \verb;porter_stem; et \verb;no_stemming;. Ces configurations sont toutes trois présentes dans \textit{ElasticSearch}. Elles correspondent respectivement au stemers KStem, PorterStem et à aucune stemmatisation. La configuration \verb;normal; utilise PorterStem par défaut. Il est à noter que par défaut, lors de la création d'un index, aucun stemming n'est effectué. \verb;normal; est configuré pour stemmer.\\

Voici une page utilisée : \url{https://www.elastic.co/guide/en/elasticsearch/guide/current/controlling-stemming.html}.

\subsection{Le retrait de mots outils (stop words)}
Pour évaluer l'influence du filtre de mots outils, la configuration \verb;no_stop_words; est testée. Cette configutation dit à son indexe de ne pas filtrer les mots outils. Pour permettre la comparaison, la configuration \verb;normal; filtre les mots outils.\\

Cette page a été utilisée : \url{https://www.elastic.co/guide/en/elasticsearch/reference/1.4/analysis-stop-tokenfilter.html}.

\subsection{La pondération des mots (ex. tf*idf)}
Pour évaluer l'influence de la pondération, la confiruation \verb;no_scoring; est testée. Cette configurationdit à son indexe de ne pas considérer ni les \textit{tf, idf} ni de normaliser. Également, la configuration \verb;no_norm; est testée. Cette configuration considère les poids \textit{tf, idf}, mais il n'y a pas de normalisation. Pour la comparaison, \verb;normal; considère tout. Pour ces configurations.\\

Cette page a été utilisée: \url{https://www.elastic.co/guide/en/elasticsearch/guide/current/scoring-theory.html}.

Pour l'exploitation des scores/poids calculés par \textit{ElasticSearch}: \url{https://www.elastic.co/guide/en/elasticsearch/reference/2.0/search-explain.html}.

\section{e) Estimation de la précision, rappel et F-mesure pour les configurations testées}

Pour chaque requête fournie dans \verb;requests.txt;, les clés de documents attendues provenant de \verb;pertinence.txt; sont comparées à celles retournées. Tel que demandé, l'opération est répétée pour chaque configuration testée. Il est possible d'imprimer les résultats moyens (pour la précsion, le rappel, la F-mesure et le MRR\footnote{Il y a une simplification qui a été appliquée au calcul du MRR : on ne considère pas d'autres clés que la première dans le fichier de pertinence. Ainsi, le \textit{rank} correspond à l'index inversé du premier document attendu dans la liste de retour, ou zéro s'il n'est pas présent.}) en roulant:

\begin{verbatim}
$ ruby analyze.rb --means
\end{verbatim}

ou

\begin{verbatim}
$ ruby analyze.rb --verbose
\end{verbatim}

pour tous les résultats intermédiaires permettant de calculer les précédentes moyennes en détails.\\

Une option est également disponible pour imprimer les graphiques (dans le répertoire \verb;graphics; sous la racine) de précision vs. rappel, ainsi que précision et rappel en fonction de l'identifiant des requêtes fournies.

\begin{verbatim}
$ ruby analyze.rb --graphics
\end{verbatim}

Finalement, il est également possible d'aller vérifier le poids

$$
w = tf \cdot idf \cdot norm
$$

pour chacun des mots d'une requête donnée, retourné pour chaque document trouvé. Par exemple, pour la requête \textit{DD15-13}:

\begin{verbatim}
$ ruby analyze.rb --weigth 13
\end{verbatim}

Une option est également présente pour tricher sur les résultats. Plus précisément, en utilisant 

\begin{verbatim}
$ ruby analyze.rb --means --cheat
\end{verbatim}

le nombre de documents pertinents qui devraient être retournés est donné en paramètre à \textit{ElasticSearch} au lieu de 50. Cette option n'est présente que pour des fins de comparaison.

\section{Observation des résultats}

\begin{center}
\begin{tabular}{|l|l|l|l|l|}
	\hline
  Nom de l'index  & $\mu$ Précision & $\mu$ Rappel & $\mu$ F-mesure & $\mu$ MRR      \\ 
  (configuration) &                 &              &                &                \\ \hline
  normal          & 0.4975          & 0.7484145991 & 0.59769146832  & 0.215862205805 \\ \hline
  no\_stemming    & 0.49083333333   & 0.7392789041 & 0.58996686276  & 0.212380969682 \\ \hline
  no\_stop\_words & 0.49958333333   & 0.7500447072 & 0.59971419145  & 0.217362212515 \\ \hline
  no\_scoring     & 0.39291666666   & 0.6547117974 & 0.49110383289  & 0.174909147234 \\ \hline
  kstem           & 0.5025          & 0.7531072445 & 0.60279421296  & 0.241271232248 \\ \hline
  porter\_stem    & 0.4975          & 0.7484145991 & 0.59769146832  & 0.215862205805 \\ \hline
  no\_norm        & 0.49041666666   & 0.7364218088 & 0.58875481322  & 0.228541954625 \\ \hline
\end{tabular}
\end{center}

Suite à l'observation des résultats, on peut voir que le retrait du \textit{stemming} et des \textit{stop words} semblent ne pas avoir une forte influence sur les performances de recherche. Fait intéressant, l'algorithme \textit{KStem} semble offrir une légère meilleure précision/rappel que l'algorithme \textit{PorterStem} par défaut. On semble observer également que la normalisation semble ne pas avoir une grande influence.\\

On voit que le facteur ayant la plus grande influence est la pondération. L'index \verb;no_scoring; qui ne pondère pas les mots (ni tf*idf, ni normalisation) est l'index qui a les moins bons résultats.\\

Comme précédemment mentionné, il est possible de vizualiser les graphiques associés à la précision et le rappel dans le répertoire \verb;graphics; après les avoir imprimés sous format html en utilisant l'option \verb;--graphics;.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}